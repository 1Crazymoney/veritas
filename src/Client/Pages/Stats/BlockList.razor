@using Microsoft.AspNetCore.SignalR.Client
@inject ApiService Api
@implements IAsyncDisposable

<div class="relative flex w-full text-white overflow-hidden justify-end">
    <div class="absolute border-b-2 border-gray-500 w-full top-9 -z-50"></div>

    @foreach (var block in Blocks)
    {
        <a @key="@block.Index" href="blocks/@block.Index"
           class="flex flex-col flex-shrink-0 p-2 text-sm text-nowrap truncate
                  transition-transform animate-[slideLeft_0.5s_ease_forwards]">
            <span class="flex justify-center align-middle p-4 rounded-md"
                  style="background-image: linear-gradient(@WebUtil.GetGradientDegrees(block.Index)deg,#c8956b,#c8ab6b,#d1ce91);">
                <Heroicon Name="@HeroiconName.Link" class="w-8 h-8"/>
            </span>

            <span class="mt-1 leading-3">
                @(block.Index.ToString("N0"))
            </span>
        </a>
    }
</div>

@code
{
    private HubConnection? _connection;

    private List<BlockDto> Blocks { get; set; } = [];

    // TODO fetch blocks from API, but continue adding realtime blocks with signalr

    public void AddBlock(BlockDto block)
    {
        Console.WriteLine($"adding block: {block.Index}");

        Blocks.Add(block);

        if (Blocks.Count > 30)
            Blocks = Blocks[1..];

        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
#if DEBUG
        var url = "http://localhost/ws";
#else
        var url = NavigationManager.ToAbsoluteUri("/ws");
#endif

        _connection = new HubConnectionBuilder()
            .WithUrl(url)
            .Build();

        _connection.On<VoteDto>("ReceiveVoteAddedEvent", vote => { Toast.ShowInfo($"received vote added event {vote.Hash} {vote.PartyId}"); });

        _connection.On<BlockDto>("ReceiveVoteAddedEvent", block =>
        {
            Toast.ShowInfo($"received block added event {block.Index} {block.Hash}");
            // TODO test
            AddBlock(block);
            InvokeAsync(StateHasChanged);
        });

        Blocks = (await Api.GetLastNBlocks(30))!.ToList();

        await _connection.StartAsync(CancellationToken);
        await base.OnInitializedAsync();
    }

    public async ValueTask DisposeAsync()
    {
        if (_connection is not null) await _connection.DisposeAsync();
    }
}